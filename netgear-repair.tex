\documentclass{sigcomm-alternate}

\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{hyperref}
\usepackage{adjustbox}
\usepackage{tikz}
\usepackage{gnuplot-lua-tikz}
\usepackage{adjustbox}
\usepackage{fp}

\newcommand{\FIXME}[1]{{\color{red}\{FIXME #1\}}}

\lstset{language=C}
\definecolor{dkgreen}{rgb}{0,0.5,0}
\definecolor{dkred}{rgb}{0.5,0,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{basicstyle=\ttfamily\bfseries\footnotesize,
  morekeywords={virtualinvoke,fucompp,fnstsw,fldl,fstpl,movl},
  keywordstyle=\color{blue},
  ndkeywordstyle=\color{red},
  commentstyle=\color{dkred},
  stringstyle=\color{dkgreen},
  numbers=left,
  numberstyle=\ttfamily\footnotesize\color{gray},
  stepnumber=1,
  numbersep=10pt,
  backgroundcolor=\color{white},
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  xleftmargin=.23in
}
\date{\today}
\title{Automated Repair of Exploits in NETGEAR Router Binary}

\begin{document}

\maketitle
\usetikzlibrary{arrows,decorations,decorations.pathreplacing,shapes}

\begin{abstract}
% WRW thinks the old Abstract put too much emphasis on Vigilante / Dawn
% Song research. In the modern era, the question isn't whether or not to
% release the exploit, but whether or not to release the patch (which can
% be reverse-engineered to get the exploit, which is then used against
% those who haven't applied the patch.)
The speed with which researchers and vendors respond to security
vulnerabilities is critical, especially after exploits have been made
available. The situation is especially dire for end users who lack
product source code and must typically fall back on techniques such as
signature generation and packet filtering, rather than addressing the root
cause. We propose an alternative in which newly-discovered exploits drive
an automated repair technique capable of patching vulnerabilities with no
access to source code or special information from the software vendor.

We propose an evolutionary automated software repair technique focused on
the special requirements of security repairs to binaries.  We adapt 
existing approaches to work on stripped ELF files, remove previous 
requirements for fault localization information, and we propose a
repair algorithm that can work without a pre-existing regression test
suite. 

We demonstrate this approach by patching recently discovered exploits
in version 4 of NETGEAR's WNDR3700 wireless router \emph{before} NETGEAR
publicly addressed the exploits. To the authors' knowledge, NETGEAR has not
patched these exploits at the time of submission. We find that even without
any regression tests, 80\% of repairs of our example exploit retain program
functionality, and with a few user-created tests, FIXME-100\% do so. 
% We discuss the feasibility and utility of this technique for the security
% community.

\end{abstract}

\section{Introduction}
\label{sec-1}
% WRW really thinks that "full disclosure" is not the fight we want to be
% making, since we'll lose. The setup for your experiments is: the exploit
% is already available, the company is slow, what can end-users do to
% protect themselves? 
Security exploits pose significant monetary and social risks. By Symantec's
count 5,291 vulnerabilities were reported in 2012
alone~\cite{symantec2013threat}. Despite this, human developers take
% ERIC: I don't have any good number for this.  It was looking for
% this number that got me on the whole to-disclose-or-not line of
% papers that led to the previous abstract.
28-FIXME-ERIC days, on average, to address security-critical defects. Even
when informed, developers do not always act immediately:  in one example,
Oracle reportedly waited months after researchers privately reported a bug
in Java while thousands of users were attacked before releasing a
fix~\cite{greenberg2012oracle}.  Compounding this, a survey of 2,000
human-written operating system fixes found that 14--24\% were
incorrect~\cite{fixes-become-bugs}: the official patch may be late, wrong,
or both.  

We propose a new option in which reproducible exploits are used to drive an
automatic repair technique. This technique operates even when developer
source code and test suites are not available, and is thus more highly
applicable. A locally-produced patch may be used for internal protection,
redistributed with the exploit (reporting an exploit with a patch in hand
has been shown to reduce the total number of attacks~\cite{arora2006does}),
or sent to the software vendor to speed the development of an official
patch~\cite{weimer06}.

In recent years, automated methods of program repair have been shown
capable of repairing defects in real software
% FIXME: For security crowd, focus on ClearView and GenProg.
(e.g.,~\cite{clearview,genprog-tse-journal,par,nguyen2013semfix}).
Methods of evolutionary program repair have been developed which are
capable of repairing defects directly in x86 or ARM ELF files,
requiring no access to program source code~\cite{schulte2013embedded}.  
We propose a new evolutionary program repair technique adapted to
the non-vendor-level repair of security vulnerabilities: neither source
code nor test suites nor any special information or cooperation from the
vendor are available. 

We demonstrate the feasibility of our technique by patching security
vulnerabilities in the widely popular NETGEAR WNDR3700 wireless router
before NETGEAR publicly addressed the exploits.  Although previous
evolutionary program repair techniques explicitly require access to a
regression test suite, we explore the feasibility of performing repair
without any such test suite and find that for our example exploit,
regression test suites are most often not necessary. In addition, we find
that the complexity of security vulnerabilities requires iterative
applications of repair actions within a single evolutionary run. 

In the remainder of this paper we review two recent exploits to the
NETGEAR WNDR3700 (Section \ref{sec-2}); demonstrate the feasibility
of running the NETGEAR firmware in a VM sandbox (Section \ref{sec-3-1});
review our novel techniques of automated program repair (Sections
\ref{sec-3-2} and \ref{on-demand-regression}); and evaluate the effectiveness of this
technique and the quality of the repairs it generates (Section
\ref{repair-demonstration}).

The novel contributions of this short paper are;
\begin{itemize}
\item a novel automated repair technique suitable for non-vendor repairs to
security vulnerabilities (not requiring source code, test cases, or fault
localization), and 
\item an application our approach to a real-world un-patched
security exploit, resulting in
\item the first demonstration of multiple iterative repairs in a single
evolutionary run.
\end{itemize}

In the pursuit of reproducible
research~\cite{buckheit1995wavelab,mesirov2010accessible} and to encourage
others to patch
future discovered exploits, we have released a companion open source
repository.\footnote{\url{https://github.com/eschulte/netgear-repair}}
This repository contains the instructions, source
code, and tooling needed to extract, execute and repair the binary
NETGEAR router image vulnerabilities, as well as the data used for the
analyses and figures in this document.
\iffalse
Additionally, the analysis performed in this document and all
supporting figures may be automatically regenerated from new
experimental data using the Org-mode reproducible research framework
\cite{schulte2012reproducible-research}.
\fi

We hope the ability to automatically patch vulnerable closed source
applications without dependence upon the software vendor encourages
users to patch vulnerable systems and researchers to release patches
with exploit announcements.

\section{Description of Exploits}
\label{sec-2}
In this work we repair two exploits in version 4 of the NETGEAR WNDR3700
wireless router. The popularity of this router means that vulnerable
systems of widespread. For example, the
``shodan''\footnote{\url{http://www.shodanhq.com/search?q=wndr3700v4+http}}
device search engine alone returns hundreds of vulnerable publicly
accessible WNDR3700 routers at the time of submission. 
Both exploits exist in the router's internal web server in a binary
executable named \texttt{net-cgi}, and both are related to how
\texttt{net-cgi} handles authentication~\cite{zcutlip}.

The vendor-deployed binary is insecure in that: 
\begin{enumerate}
\item Any URI starting with the string ``{\tt BRS}'' bypasses authentication.

\item Any URI including the substring ``{\tt unauth.cgi}'' or
  ``{\tt securityquestions.cgi}'' bypass authentication. This applies
  even to requests of the form 
  \texttt{http://router/page.html?foo=unauth.cgi}, meaning that 
  the vulnerability effectively applies to all internal webpages. 
\end{enumerate}

Many administrative pages start with the ``{\tt BRS}'' string, providing
attackers with access to personal information such as 's
passwords, and by accessing the page
\texttt{http://router/BRS\_02\_genieHelp.html} attackers can
completely disable authentication in a manner which is permanent
across reboots.

\section{Repair Technique}
\label{sec-3}

Our repair technique for this vulnerability consists of three stages:
\begin{enumerate}
\item Extract the binary executable from the firmware and reproduce
the exploit (Section~\ref{sec-3-1}).
\item Apply evolutionary program repair techniques based on mutations to
that stripped MIPS ELF binary (Section~\ref{sec-3-2}). 
\item Lazily construct test cases, as needed, to improve the quality of
unsatisfactory candidate repairs (Section~\ref{on-demand-regression}). 
\end{enumerate} 

The first step in repairing the \texttt{net-cgi} executable is extracting
it and the router file system from the firmware image distributed by
NETGEAR.  Using the extracted filesystem and executable we construct a test
harness used exercise the exploits in \texttt{net-cgi}.  This test harness
is used by the repair algorithm to evaluate candidate repairs and to
identify when repairs to the exploits have been found.

\subsection{Firmware Extraction and Virtualization}
\label{sec-3-1}
NETGEAR distributes firmware holding a full system image for the
WNDR3700 router which include the router file system holding the
vulnerable \texttt{net-cgi} executable. Our prototype repair tool
extracted the file system using the 
\texttt{binwalk}\footnote{\url{http://binwalk.org}} firmware extraction
tool. Such tools scan the binary data in the raw monolothic firmware file,
searching for signatures
identifying the types of embedded data sections.  The \texttt{binwalk} tool
includes rules for identifying and extracting common embedded data
types, including the {\tt squashfs}\cite{lougher2006squashfs} which
holds the router's file system.

The router runs on a big-endian MIPS architecture, and thus safely
reproducing the exploit and evaluating candidate repairs requires emulation
on most desktop systems. Our prototype implementation uses the QEMU system
emulator~\cite{bellard2005qemu} to emulate this architecture in a
lightweight manner; a Debian Linux operating system is run in emulation.
The extracted router file system is copied into the emulated MIPS Linux
system.  A number of special directories (e.g., \texttt{/proc/},
\texttt{/dev/} etc.) are mounted inside the extracted file system and bound
to the corresponding directories on the virtual machine.  At this point,
commands may be executed in an environment which closely approximates the
execution environment of the NETGEAR router using the \texttt{chroot}
command to confine executable access to within the extracted NETGEAR file
system. Additional minor adjustments are described in full in the
reproduction information.

At this point the NETGERA router may be run in virtualization.  In
particular, the web interface of the router may be accessed either using an
external web browser or the \texttt{net-cgi} executable may be called
directly from the command line.

\subsection{Automated Program Repair and ELF Files}
\label{sec-3-2}

Evolutionary program repair
\cite{forrest2009genetic,genprog-tse-journal,le2012representations,legoues2011systematicstudy}
uses natural selection to search for or ``evolve'' modified versions
of existing programs which differ from the original in that they do
not exhibit specific undesired buggy behavior.  This process normally
requires access to the source code of the original program which is
modified or ``mutated'' by the evolutionary repair technique to
generate program variants.  These variants are assigned a fitness by
running them against the program's existing test suite, as well as an
additional test which demonstrates the undesired behavior.

The repair algorithm builds and maintains a population of these
program variants.  This population evolves through repeated mutation
and evaluation until a version of the original program is found which
satisfies the regression test suite and no longer exhibits the
undesired behavior.

We present a modified evolutionary program repair algorithm which is
suited to the unique needs of users attempting to repair faults in
binary executables (Section \ref{mutate-mips}) without access to the
any regression test suite (Section \ref{on-demand-regression}).

\subsubsection{Challenge: Mutating Stripped Binaries}
\label{mutate-mips}

Executable programs for Unix and embedded system are commonly distributed
as ELF (Executable and Linking Format)~\cite{tis1995tool} files. 
Each ELF file contains a number of headers
and tables containing administrative data, and sections holding
program code and data.  The three main administrative elements of an
ELF file are the ELF header, the section table and the program table
(see Figure \ref{elf}).  The ELF header points to the section table and the
program table, the section table holds information on the layout of
sections in the ELF file on disk, and the program table holds
information on how to copy section from disk into memory for program
execution.

Our proposed approach to repairing stripped MIPS ELF files is an extension
of previous work on the evolutionary repair of unstripped Intel and ARM
files~\cite{schulte2013embedded}. 
Mutation operations are used to modify the
execution behavior of the ELF file.  In this case the \texttt{net-cgi} file
is stripped a minimal ELF file which does not include much of the
information assumed to exist by previous repair techniques.

\begin{figure}[htb]
  \centering
  \adjustbox{width=0.4\textwidth}{
\begin{tikzpicture}
  % ELF File
  \node[draw, rectangle, minimum height=11.5em, minimum width=8em] (whole) at (0,0) {};
  \node[minimum width=8em] (header) at (0,1.65) {ELF Header};
  \draw[thick] (header.south west) -- (header.south east);
  \node[minimum width=8em] (st) at (0,1) {Section Table};
  \node[minimum width=8em] (body1) at (0,0.25) {...};
  \node[minimum width=8em] (body2) at (0,-0.25) {Section Data};
  \node[minimum width=8em] (body3) at (0,-0.75) {...};
  \node[minimum width=8em] (pt) at (0,-1.5) {Program Table};
  % External Users
  \node[draw, ellipse, fill=blue!20, minimum height=3em, minimum width=6em] (linker) at (-3,1) {Linker};
  \node[draw, ellipse, fill=red!20, minimum height=3em, minimum width=6em]  (memory) at (3,-1.5) {Memory};
  % Arrows to Users
  \draw[->,thick] (st.west) to (linker.east);
  \draw[->,thick] (pt.east) to (memory.west);
  % Section Table Arrows
  \draw[->,thick,densely dotted,bend right=90] (body1.east) to (st.east);
  \draw[->,thick,densely dotted,bend right=90] (body2.east) to (st.east);
  \draw[->,thick,densely dotted,bend right=90] (body3.east) to (st.east);
  % Program Table Arrows
  \draw[->,thick,densely dotted,bend right=90] (body1.west) to (pt.west);
  \draw[->,thick,densely dotted,bend right=90] (body2.west) to (pt.west);
  \draw[->,thick,densely dotted,bend right=90] (body3.west) to (pt.west);
\end{tikzpicture}
}
\caption{\label{elf}Sections and their uses in an Executable and
  Linking Format (ELF) file.}
\end{figure}

While the majority of ELF files include all three of these elements,
only the ELF Header is guaranteed to exist in all cases.  In
executable ELF files the program table is required, and in linkable
files the section table is required.

Previous work required a section table and a section
name string table, which were used to find the \texttt{.text} section of the
ELF file where program code is normally stored.  The data in the
\texttt{.text} section was then coerced into a genome, a linear array of
assembly instructions which was modified by the mutation operations.
Our extension of this technique does not require a section table.
Instead, we build the genome by concatenating the data of every section
in the program table which has a ``loadable'' type.  These are the
sections whose data are loaded into memory during program execution.

Mutation operations must change program data without corrupting the
structure of the file or breaking the many addresses hard coded into
the program data itself (e.g., as destinations for conditional jumps). 
In general, it is impossible to distinguish
between an integer literal and an address in program data.  For this
reason, we propose mutation operations designed to preserve operand absolute
sizes and offsets within of the ELF program data.  This is made
easier because every argumented assembly instruction in the MIPS RISC 
architecture is one word long~\cite{hennessy1982mips}.  Our mutation and
crossover operations used to modify stripped MIPS ELF files are shown in
Figure~\ref{mutation-ops}.

\tikzstyle{asmrow} = [rectangle, draw, minimum width=2em, minimum height=1em]
\begin{figure}[htb]
  \centering
\begin{tikzpicture}
  % Mutation
  \foreach \x in {-3.5,-2.5,-0.5,0.5,2.5,3.5}{
    \foreach \y in {-0.8,-0.4,0,0.4,0.8}{
      \node[asmrow,fill=green!40] at (\x,\y) {};
    }
  }
  % Replace
  \node at (-3,1.25) {Replace};
  \node[asmrow,fill=yellow!20] (c-from) at (-3.5,0.4) {};
  \node[asmrow,fill=blue!60] at (-3.5,-0.4) {};
  % replace-after
  \node[asmrow,fill=yellow!20] at (-2.5,0.4) {};
  \node[asmrow,fill=yellow!20] (c-to) at (-2.5,-0.4) {};
  \node[asmrow,fill=green!40]  at (-2.5,-0.8) {};
  % Delete
  \node at (0,1.25) {Delete};
  \node[asmrow,fill=red!40] (d-from) at (-0.5,0) {};
  % delete-after
  \node[asmrow,fill=white] (d-to) at (0.5,0) {\scriptsize{0x0}};
  % Swap
  \node at (3,1.25) {Swap};
  \node[asmrow,fill=yellow!20] (s1-from) at (2.5,0.4) {};
  \node[asmrow,fill=blue!60] (s2-from) at (2.5,-0.4) {};
  % swap-after
  \node[asmrow,fill=blue!60] (s2-to) at (3.5,0.4) {};
  \node[asmrow,fill=yellow!20] (s1-to) at (3.5,-0.4) {};
  % arrows
  \draw[->,thick] (c-from.east) to (c-to.west);
  \draw[->,thick] (d-from.east) to (d-to.west);
  \draw[->,thick] (s1-from.east) to (s1-to.west);
  \draw[->,thick] (s2-from.east) to (s2-to.west);
  % Crossover
  \node at (0,-1.7) {One Point Crossover};
  \foreach \x in {-1.5,1.5}{
    \foreach \y in {-3.8,-3.4,-3,-2.6,-2.2}{
      \node[asmrow,fill=green!40] at (\x,\y) {};
    }
  }
  \foreach \x in {-0.5}{
    \foreach \y in {-3.8,-3.4,-3,-2.6,-2.2}{
      \node[asmrow,fill=blue!60] at (\x,\y) {};
    }
  }
  \draw[->,thick] (-2,-3.2) to (2,-3.2);
  \node[asmrow,fill=blue!60] at (1.5,-3.4) {};
  \node[asmrow,fill=blue!60] at (1.5,-3.8) {};
\end{tikzpicture}
\caption{Mutation and Crossover operations for stripped MIPS ELF files.  The
  program data is represented as a fixed length array of single-word
  sections.  These operators change these sections maintaining length
  and offset in the array.}
  \label{mutation-ops}
\end{figure}

\subsection{On-Demand Regression Testing}
\label{on-demand-regression}

A critical challenge in automated program repair is assessing the
validity of a candidate repair.  The mutations used by these
techniques are random in that they do not take into account or
preserve the semantics of the program and are thus as or more likely
to create new bugs or exploits as they are to repair existing
undesired behavior.

In contrast to previous approaches, our evolutionary program repair
algorithm does not require a pre-existing regression test suite.
Instead, we only assume that a demonstration of the exploit exists,
and treat that as a single available test.  By mutating programs
without the net of a regression test suite our evolved repairs often
introduce significant regressions.  Fortunately we find that a post
evolution repair minimization process in which the difference between
the evolved repair and the original program is minimized to as few
edits as possible using Delta Debugging~\cite{delta} removes these
regressions in the majority of cases (Section \ref{minimization}).  We
trust to the user to identify regressions which are not eliminated
through minimization in the interactive portion of our repair
algorithm.  High level pseudocode for the repair algorithm is show in
Listing \ref{lazy-algorithm}.

Our approach is thus an interactive repair process in which the
algorithm searches for a patch that 
passes every available test (starting with only the exploit). 
Whenever a candidate repair is produced that passes all available tests,
the user evaluates its suitability. If the repair is accepted, the process
terminates. Otherwise, the user supplies a new regression test that the repair
fails (a witness to its unsuitability) and the process repeats. 
In Section \ref{repair-demonstration} we find that 80\% of our
attempts to repair the NETGEAR WNDR3700 exploits did not require any
user-written regression tests.

\begin{figure}[htb]
\begin{algorithmic}[1]
\small
\item[{\textbf{Input: }} {Vulnerable Program, $\mathsf{original}$ : $ELF$}]
\item[{\textbf{Input: }} {Exploit Tests, $\mathsf{exploits}$ : $[ELF \rightarrow Fitness]$}]
\item[{\textbf{Input: }} {Interactive Check, $\mathsf{good-enough}$ : $ELF \rightarrow [ELF \rightarrow Fitness]$}]
\item[{\textbf{Output: }} {Patched version of Program}] 
  \STATE {\bf let} $new \leftarrow \mathsf{null}$ 
  \STATE {\bf let} $fitness \leftarrow \mathsf{null}$ 
  \STATE {\bf let} $suite \leftarrow \mathsf{exploits}$ 
  \REPEAT {
    \STATE {\bf let} $\mathsf{full} \leftarrow \mathsf{evolutionarySubroutine}(\mathsf{original}, \mathsf{suite})$
    \STATE $new \leftarrow \mathsf{minimize()}$
    \STATE {\bf let} $newRegressionTests \leftarrow \mathsf{good-enough}(\mathsf{new})$ 
    \STATE $\mathsf{suite} \leftarrow \mathsf{suite} ++ \mathsf{newRegressionTests}$
  }
  \UNTIL { $length(\mathsf{newRegressionTests}) \equiv 0$ }
  \RETURN { $\mathsf{new}$ }
\end{algorithmic}
\caption{\label{lazy-algorithm}High-level Pseudocode for interactive
lazy-regression-testing repair algorithm.}
\end{figure}

The \texttt{evolutionary\_subroutine} in Listing \ref{lazy-algorithm} has
the same high level organization as previous work~\cite{genprog-tse-journal},
but it uses a \emph{steady state}
evolutionary computational algorithm~\cite{Luke2013Metaheuristics} for
reduced memory usage and ease of parallelization of fitness evaluation.
High level pseudocode for the \texttt{evolutionary\_subroutine} is shown in
Listing \ref{evolutionary-subroutine}.

\begin{figure}[htb]
\begin{algorithmic}[1]
\small
\item[{\textbf{Input: }} {Vulnerable Program, $\mathsf{original}$ : $ELF$}]
\item[{\textbf{Input: }} {Test Suite, $\mathsf{suite}$ : $[ELF \rightarrow Fitness]$}]
\item[{\textbf{Parameters: }} {$populationSize$, $tournamentSize$, $crossRate$}]
\item[{\textbf{Output: }} {Patched version of Program}] 
  \STATE {\bf let} $fitness \leftarrow \mathsf{evaluate}(\mathsf{original}, \mathsf{suite})$ 
  \STATE {\bf let} $pop \leftarrow \mathsf{populationSize}$ copies of $\langle \mathsf{original}, \mathsf{fitness} \rangle$
  \REPEAT {
    \IF {$\mathsf{Random}() < CrossRate$}
      \STATE {\bf let} $\mathsf{p_{1}} \leftarrow \mathsf{crossover}(\mathsf{tournament}(\mathsf{pop}, \mathsf{tounamentSize}, +))$
      \STATE {\bf let} $\mathsf{p_{2}} \leftarrow \mathsf{crossover}(\mathsf{tournament}(\mathsf{pop}, \mathsf{tounamentSize}, +))$
      \STATE {\bf let} $\mathsf{p} \leftarrow \mathsf{crossover}(\mathsf{p_{1}}, \mathsf{p_{2}})$
    \ELSE
      \STATE $p \leftarrow \mathsf{tournament}(\mathsf{pop}, \mathsf{tounamentSize}, +)$
    \ENDIF
    \STATE {\bf let} $p' \leftarrow \mathsf{Mutate}(p)$
    \STATE {\bf let} $fitness \leftarrow \mathsf{evaluate}(\mathsf{suite}, \mathsf{p'})$
    \STATE $\mathsf{incorporate}(pop,\langle p', \mathsf{Fitness}(\mathsf{Run}(p')) \rangle)$
    \IF {$\mathsf{length}(\mathsf{pop}) > \mathsf{maxPopulationSize}$}
      \STATE $\mathsf{evict}(\mathsf{pop}, \mathsf{tournament}(\mathsf{pop}, \mathsf{tounamentSize}, -))$
    \ENDIF
  }
  \UNTIL { $\mathsf{fitness} > \mathsf{length}(\mathsf{suite})$ }
  \RETURN { $\mathsf{p'}$ }
\end{algorithmic}
\caption{\label{evolutionary-subroutine}High-level Pseudocode for the
steady state parallel evolutionary repair subroutine.}
\end{figure}

Note that every time the user rejects the
solution returned by \texttt{evolutionary\_subroutine}, the evolved and
minimized solution is discarded and a new population is generated by
again copying the original by the \texttt{evolutionary\_subroutine}.  Unlike
most applications of EC, but as in nature, our EC of extant programs
always starts from a point in the fitness landscape which is very
nearly optimal.  This is because the original program is not a random
combinations of instructions, but is instead 
a highly engineered solution to the program fitness
landscape.  This algorithmic choice acknowledges the fitness of the
original program, and for this reason gives it primacy over the
evolved solutions of previous iterations (which may well have evolved
into fitness valleys as in run 8 Table \ref{minimized-stats}).

\section{Repair Demonstration}
\label{repair-demonstration}

We first describe the methodology with which we applied our
evolutionary repair technique to the NETGEAR WNDR3700 exploit (Section
\ref{methodology}).  We then analyze the results of ten repair
attempts (Section \ref{analysis}).

\subsection{Methodology}
\label{methodology}
We demonstrate our technique by patching two NETGEAR WNDR3700
exploits.  All repairs were performed on a server-class machine with
32 physical Intel Xeon 2.60GHz cores, Hyper-Threading and 120 GB of
Memory.  In this section we first describe the test harness with which
program variants are assigned a fitness (Section
\ref{fitness-evaluation}), then we provide the parameters with which
we applied our on-demand evolutionary program repair algorithm
(Section \ref{sec:parameters}).

\subsubsection{Fitness Evaluation}
\label{fitness-evaluation}
To perform fitness evaluations we use 32 QEMU virtual machines, each
running Debian Linux with the NETGEAR router firmware environment
available inside of a \texttt{chroot}.  The repair algorithm itself
uses 32 threads for parallel fitness evaluation.  Each thread is
paired with a single QEMU VM on which it tests fitness.

The test framework includes both a host and a guest test script.  The
host script runs on the server performing repair and a guest script
which runs in a MIPS virtual machine.  The host script copies a
variant of the \texttt{net-cgi} executable to the guest VM where the
guest test script runs \texttt{net-cgi} on the command line and
reports a result of {\sc Pass}, {\sc Fail}, or {\sc Error} for each
test.  These values are then used to calculate the variant's scalar
fitness.

{\sc Pass} indicates that the program completed successfully and
produced the correct result, {\sc Fail} indicates that the program
completed successfully but produced an incorrect results, and {\sc
  Error} indicates that the program execution did not complete
successfully due to early termination (e.g., because of a segfault) or
indicated by a non-zero ``errno'' exit value.

\subsubsection{Repair Parameters}
\label{sec:parameters}
Repair was run using the parameters shown in Table \ref{parameters}.  The
maximum population size was 512 individuals, selection is performed
using a tournament size of two.  When the population overflows the
maximum population size, an individual is selected for eviction using
a negative tournament of size two.  Newly selected individuals are
crossed over two-thirds of the time.

\begin{table}[htb]
\centering
\begin{tabular}{lr}
parameter           & value         \\
\hline
max-population-size & 512           \\
tournament-size     & 2             \\
crossover-rate      & $\frac{2}{3}$ \\
\end{tabular}\caption{\label{parameters}The parameters used to evolve repairs to the NETGEAR WNDR3700 exploits.}

\end{table}

These parameters differ significantly from those used in previous EC
repair algorithms
(e.g.,~\cite{forrest2009genetic,legoues2011systematicstudy,le2012representations})
in that we
use larger populations (of 512 instead of 40 individuals), running for
many more fitness evaluations ($\leq$100,000 instead of $\leq$400).  The
parameters used in this paper are closer to traditional EC
parameters given the size of the software genome, and allow our
technique to overcome the lack of any fault localization information.

The increased memory required by the larger population size is offset
by the use of a steady state EC algorithm, and the increased
computational demand of the greater number of fitness evaluations is
offset by parallelization of fitness evaluation.

\subsection{Analysis of Repairs}
\label{analysis}

We provide information on the typical time required to perform repair
(Section \ref{runtime}).  We then review the impact of the
minimization process (Section \ref{minimization}) both with respect to
the size of the repair in terms of byte difference from the original
and in terms of the fitness improvement.  Finally we demonstrate the
iterative nature of our repairs in (Section \ref{iterative-repair}).

\subsubsection{Repair Runtime}
\label{runtime}
The time taken to perform a fitness evaluation varies with the size of
the regression suite.  Table \ref{test-speed} shows the time taken to
perform 1000 fitness evaluations on a single virtual machine over a
variety of regression test sizes.

\begin{table}[htb]
\centering
\begin{tabular}{l|r}
suite size & Seconds for 1000 evaluations \\
\hline
3          & 3297                         \\
4          & 3759                         \\
7          & 5766                         \\
11         & 7853                         \\
\end{tabular}
\caption{\label{test-speed}A single virtual machine is able to perform
  1000 sequential fitness evaluations in the given number of seconds,
  shown by the toal number of tests included in the fitness
  function.}
\end{table}

In 8 of the 10 attempted repairs only the three exploit tests were
used with no regression tests run.  This corresponds to the first line
of Table \ref{test-speed}.  In these cases the repair process took
86.6 minutes on average.

\subsubsection{Minimization Impact}
\label{minimization}

In some cases the initial evolved repair was not satisfactory.  For
example, evolved repairs sometimes worked when \texttt{net-cgi} was
called directly on the command line but not through the embedded
$\mu$HTTPd webserver,\footnote{\url{http://wiki.openwrt.org/doc/uci/uhttpd}}
or the evolved file failed to serve pages not used in the
exploit test.  As shown in Table \ref{minimized-stats}, however, in most
cases the minimized version of the evolved executable was satisfactory
and passed all hand-written regression tests available, even those not used
during the repair process. 

\begin{table}[htb]
\centering
\begin{tabular}{rrrrrr}
Run  & Fit Evals & Full Diff & Min Diff & Full Fit & Min Fit \\
\toprule
0    & 90405     & 500       & 2        & 8        & 22      \\
1    & 17231     & 134       & 3        & 22       & 22      \\
2    & 26879     & 205       & 2        & 21       & 22      \\
3    & 23764     & 199       & 2        & 19       & 22      \\
4    & 47906     & 319       & 2        & 6        & 6       \\
5    & 13102     & 95        & 2        & 16       & 22      \\
6    & 76960     & 556       & 3        & 17       & 22      \\
7    & 11831     & 79        & 3        & 20       & 22      \\
8    & 2846      & 10        & 1        & 14       & 14      \\
9    & 25600     & 182       & 2        & 21       & 22      \\
\bottomrule
mean & 33652.4   & 227.9     & 2.2      & 16.4     & 19.6    \\
\end{tabular}
\caption{\label{minimized-stats}Difference and functionality of
evolved repair before and after minimization.  In these columns ``Full''
refers to evolved solutions before minimization and ``Min'' refers to
post-minimization solutions.  Columns labeled ``Diff'' report the number
of unified diff windows against the original program data. The columns
labeled ``Fit'' report the fitness measured with a full regression test
suite including the exploit tests with a maximum fitness of 22.}
\end{table}

As shown in Table \ref{minimized-stats}, the initial evolved repair
differed from the original at over 200 locations on average in the ELF
program data, while the minimized repairs differed at only 1--3
locations on average.  This great discrepancy is due to the
accumulation of candidate edits in non-tested portions of the program
data.  Since these portions of the genome were not tested, there was
no evolutionary pressure to purge harmful edits.  The elimination of
these accumulated edits is the main purpose of our minimization step,
and is the reason for the consistent increase in regression test
behavior found in the minimized repairs.

\subsubsection{Iterative Repair}
\label{iterative-repair}
These repairs required two distinct fixes addressing two different
exploits in a single evolutionary run.  This is an instance of
``iterative repair'' which has not previously been observed in the
repair of real-world extant software.

\begin{figure}[htb]
  \centering
  \includegraphics[bb=0 0 355 248,width=0.46\textwidth]{fitness-improvement.pdf}
  % \input{fitness-improvement.tex}
  \caption{Mean fitness as a function of the number of fitness
    evaluations.  Collected over 10 runs using only the two exploits
    to access variant fitness.  A fitness of 3 indicates that all
    three tests are failed but do not throw an error.  A fitness value
    of 6 passes all three tests.  One exploit is exercised by two
    tests, so typically a run fixes either the 1-test or 2-test
    exploit first, then fixes the second later.  These two different
    repair scenarios are clearly visible in the graph.}
  \label{fit-by-time}
\end{figure}

\section{Related Work}
\label{sec-5}
\subsection{Security}
\label{sec-5-1}
% There has been a significant effort to understand the impacts of
% disclosure of discovered exploits.  Researchers typically must decide
% between public disclosure (termed ``full disclosure'') or private
% disclosure to the vendor of the vulnerable software.  The former
% increases the number of attacks in the short term \cite{arora2006does},
% while the later risks the vendor ignoring the exploit extending the
% life of the exploit.

Even major software vendors commonly delay releasing patches to
security exploits.  Microsoft waits until the second Tuesday of every
month (known as ``Patch Tuesday'') to release security patches
\cite{lemos2003microsoft}, leading malicious users to release new
exploits on the second Wednesday of every month (known as ``Exploit
Wednesday'') to maximize the time before a patch is released.

In a study of high and medium risk vulnerabilities in Microsoft and
Apple products between 2002 and 2008, about 10\% of
vulnerabilities were found not to be patched within 150 days of
disclosure, and on any given date about 10 vulnerabilities and over 20
vulnerabilities were public and un-patched for Microsoft and Apple
respectively \cite{frei20080}.

FIXME: more related security work.

\subsection{EC}
\label{sec-5-2}

FIXME: EC background

\subsection{Automated Program Repair}
\label{sec-5-3}

FIXME

\begin{itemize}
\item genprog
\item clearview
\item semfix
\end{itemize}

\section{Discussion}
\label{sec-6}
This technique demonstrates the ability of end users to fix software
exploits in closed source software without any special information or
aid from the software vendor.

\subsection{Threats to Validity}
\label{sec-6-1}
This initial work is based upon a single exploit repair so it is
possible that the results indicating the effectiveness of repair
without any regression test suite will not generalize.  However, the
authors do not believe that these results are based on any property
unique to the NETGEAR exploits. Rather, we believe that the ability of
the evolutionary repair algorithm to find functional repairs without
the use of any regression test suite is due to both the beneficial
impact of minimization, and to the natural mutational robustness of
software. Specifically, Schulte \emph{et al.}~\cite{schulte2013software} 
find that the functionality of software mutants differs by only about 60\%
between software tested with an empty regression test suites and software
tested with the best obtainable quality regression test suites.

\subsection{Next Steps}
\label{sec-6-2}

\begin{itemize}
\item operation directly on a binary image
\begin{itemize}
\item would require better virtualization
\item would require better fault localization
\end{itemize}
\item proactive hardening
\begin{itemize}
\item shutting off (read:breaking) insecure functionality such as
password reset
\item combination with a fuzz tester in a closed exploit/repair loop
\end{itemize}
\item distributed diversity
\begin{itemize}
\item self certifying patches
\end{itemize}
\item Use ``neutral'' mutations to mask the important aspects of a
  patch to avoid patch reverse-engineering.  As this work demonstrates
  there are often hundreds of extra mutations.
\end{itemize}

\section{Acknowledgments}
\label{sec-7}
Foremost we'd like to thank Zachary Cutlip who analyzed and announced
the NETGEAR exploits, and who helped us to reproduce the exploits
locally.  Without his help this work would not have been possible.  We
would also like to thank Mark Harman for discussion of program repair
without a regression test suite, and Stephen Harding for initially
formulating the interactive lazy regression repair algorithm.

Also, GRANTS GRANTS GRANTS.

\bibliographystyle{plain}
\bibliography{netgear-repair}

\end{document}
