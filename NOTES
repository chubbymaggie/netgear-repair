# -*- org -*-
#+Options: ^:{}

* Reproduction
** Setting up the VM
1. Following the instructions from [[http://shadow-file.blogspot.com/2013/05/running-debian-mips-linux-in-qemu.html][running-debian-mips-linux-in-qemu]]
   download the files in the =mips= subdirectory of
   http://people.debian.org/~aurel32/qemu/ and save them to
   =debian-qemu/be=.

2. Ensure a new version of QEMU is installed, and that you have a
   network bridge setup following the instructions in [[https://wiki.archlinux.org/index.php/QEMU][QEMU]] and
   [[https://wiki.archlinux.org/index.php/Bridge_with_netctl][Bridge_with_netctl]].

3. You'll want configure ssh access and install binwalk.  From this
   point on the VM shouldn't require external internet access.  Note:
   Although the =run-vm= executable is configured to work with either
   big endian or little endian mips images, we'll only use the big
   endian version as that is the architecture of the NETGEAR router.
   1. start the vm
      #+begin_src sh
        export ENDIANESS=be
        bin/run-vm -b -D
      #+end_src
   2. as root in the qemu window, install sshd
      #+begin_src sh
        apt-get update
        apt-get install openssh-server
      #+end_src
   3. shutdown the VM's and kill the qemu processes

4. install binwalk (more easily done on a Debian system)
   #+begin_src sh
     wget https://binwalk.googlecode.com/files/binwalk-1.2.2-1.tar.gz
     tar xzf binwalk-1.2.2-1.tar.gz
     cd binwalk-1.2.2-1/src/
     ./debian_quick_install.sh # on Debian, else manually satisfy dependencies
   #+end_src

5. Now to grab the NETGEAR firmware and extract the filesystem
   #+begin_src sh
     wget \
       http://www.downloads.netgear.com/files/GDC/WNDR3700V4/WNDR3700V4_V1.0.1.42.zip
     unzip WNDR3700V4_V1.0.1.42.zip
     binwalk -e WNDR3700v4-V1.0.1.42.img
   #+end_src
   we can now see the broken cgi file in the extracted filesystem.
   #+begin_src sh
     file _WNDR3700v4-V1.0.1.42.img.extracted/squashfs-root/usr/sbin/net-cgi
   #+end_src

6. Copy the squashfs filesystem to the QEMU VM.
** Run the original =net-cgi= from the command line in the VM
1. The web server on the NETGEAR router (=uhttpd=) calls =net-cgi= for
   basically every web page.  We'll want to call =net-cgi= from the
   command line.  Every header passed in by =uhttpd= may be passed on
   the command line as an environment variable.  The script in
   file:bin/call-cgi will handle this for us.

2. We need to run =net-cgi= from within the NETGEAR firmware, since
   this is unpacked into =~/squashfs-root= in our VM, the command to
   invoke =net-cgi= will need to us =chroot=.  However at this point
   =net-cgi= will segfault trying to read files in =/proc= (thanks to
   =strace= for debugging help here).  We can map =/proc=, =/lib/init=
   and =/dev= from the VM into =squashfs-root= with the following.
   #+begin_src sh
     mount -o bind /proc  squashfs-root/proc
     mkdir squashfs-root/lib/init
     mount -o bind /lib/init/  squashfs-root/lib/init
     mount -o bind /dev/  squashfs-root/dev
   #+end_src

3. We'll also need to start the =datalib= service which appears to
   make configuration information available to =net-cgi=, and then set
   the value of the =dns_hijack= configuration to "0" to avoid 404
   errors.
   #+begin_src sh
     chroot squashfs-root/ /bin/datalib
     chroot squashfs-root/ /bin/config set dns_hijack="0"
   #+end_src

4. After all of this we can now call =net-cgi= from the command line
   with the following.
   #+begin_src sh
     URI="index.htm" call-cgi chroot squashfs-root /usr/sbin/net-cgi
   #+end_src

** Build a pool of overlays for candidate repair evaluation
1. Generate multiple overlays.
   #+begin_src sh
     make-overlay overlays/{0..9}.qcow2
   #+end_src

** Evolve a version of =net-cgi= without the exploit
* Notes
** NETGEAR GPL-mandated open-source release
- http://kb.netgear.com/app/answers/detail/a_id/2649
- http://www.downloads.netgear.com/files/GPL/WNDR3700V4_V1.0.1.42_gpl_src.zip

** =net-cgi= tests
Positive Tests
- ensure serves up a variety of pages as normal

Negative Tests
- no authentication for =BRS_*= files
- no authentication if =unauth.cgi= or =securityquestions.cgi= are in
  the path, even in the query string, e.g., 
  : http://router_address/protected_page.htm?foo=unauth.cgi
- browsing to the following sets =hijack_process= to something other
  than three in the nvram, disabling authentication checks
  : http://router_address/BRS_02_genieHelp.html
** =net-cgi= segfaults
*** look through =strace= output
file:stuff/net-cgi.strace

Narrative of net-cgi execution
1. open a socket
   : socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 3
   : connect(3, {sa_family=AF_INET, sin_port=htons(2313), sin_addr=inet_addr("127.0.0.1")}, 16) = 0
   : setsockopt(3, SOL_SOCKET, SO_NO_CHECK, [1], 4) = 0
   : sendto(3, "\2GUI_Region", 11, 0, NULL, 0) = 11
2. find the language
3. read the appropriate =www/languages-XX.js= file
4. open =/proc/partitions= and call =df= writing results to =/tmp/df_out=
5. send a number of things to the socket opened in (1)
6. attempt to open =/proc/net/arp=, fail and segfault
   : open("/proc/net/arp", O_RDONLY|O_LARGEFILE) = -1 ENOENT (No such file or directory)
   : rt_sigaction(SIGQUIT, {0x10000000, [], SA_NOCLDSTOP}, {0x10000000, [], 0}, 16) = 0
   : rt_sigaction(SIGINT, {0x10000000, [], SA_NOCLDSTOP}, {0x10000000, [], 0}, 16) = 0
   : rt_sigaction(SIGCHLD, {0x10000000, [], 0}, {0x10000000, [], 0}, 16) = 0
   : fork()                                  = 1376
   : rt_sigaction(SIGQUIT, {0x10000000, [], SA_NOCLDSTOP}, {0x10000000, [], SA_NOCLDSTOP}, 16) = 0
   : rt_sigaction(SIGINT, {0x10000000, [], SA_NOCLDSTOP}, {0x10000000, [], SA_NOCLDSTOP}, 16) = 0

We can run with bridge networking while connected to ethernet, and
then mount the real =/proc= into our chroot file system.
: mount -o bind /proc  squashfs-root/proc

** system wide set LD_PRELOAD
Looks like you can copy the file to =/etc/ld.so.preload=.

** Running the webserver (=uhttpd=) in the firmware
From the root of the firmware FS we see that [[http://wiki.openwrt.org/doc/howto/http.uhttpd][uhttpd]] is the webserver used.
: # find ./ -name "*htt*"
: ./www/help/_green_download_http_help.html
: ./www/cgi-bin/uhttpd.sh
: ./etc/config/uhttpd
: ./etc/rc.d/S50uhttpd
: ./etc/init.d/uhttpd
: ./usr/lib/opkg/info/uhttpd-mod-tls.list
: ./usr/lib/opkg/info/uhttpd.list
: ./usr/lib/uhttpd_tls.so
: ./usr/sbin/uhttpd

The webserver may be started with the following (from within =chroot=).
: /www/cgi-bin/uhttpd.sh start

** calling net-cgi from the command line
*** the calling process
1. turn on the data directory with
   #+begin_src sh
     chroot squashfs-root/ /bin/datalib
   #+end_src

   you should see something like

   : Loading data from /dev/mtd5 ...
   : Resetting to default values ...
   : The data center is Running ...

2. Turn off =dns_hijack=, else you'll get 404 errors for every page...
   #+begin_src sh
     chroot squashfs-root/ /bin/config set dns_hijack="0"
   #+end_src

3. Now we can finally get real web pages calling =net-cgi= from the
   command line.
   #+begin_src sh
     URI="index.htm" call-cgi chroot squashfs-root /usr/sbin/net-cgi
   #+end_src

*** find how net-cgi is called
Replacing =net-cgi= with the following shows how it is called by the web-server.
#+begin_src sh
  #!/bin/sh
  
  cat <<EOF
  Content-type: text/plain
  
  I was called with the following.
  
  arguments:
  $@
  
  environment:
  $(env)
  
  stdin:
  $(cat -)
  
  Bye.
  EOF
#+end_src

With the webserver started calling =wget http://localhost/= will write
the following to =index.html=.
: I was called with the following.
: arguments:
: 
: 
: environment:
: GATEWAY_INTERFACE=CGI/1.1
: REMOTE_HOST=127.0.0.1
: REMOTE_ADDR=127.0.0.1
: QUERY_STRING=
: HTTP_USER_AGENT=Wget/1.12 (linux-gnu)
: DOCUMENT_ROOT=/www
: REMOTE_PORT=56786
: HTTP_ACCEPT=*/*
: SCRIPT_FILENAME=/www/start.htm
: HTTP_HOST=localhost
: REQUEST_URI=/
: SERVER_SOFTWARE=uHTTPd
: HTTP_CONNECTION=Keep-Alive
: PATH=/sbin:/usr/sbin:/bin:/usr/bin
: SERVER_PROTOCOL=HTTP/1.0
: REQUEST_METHOD=GET
: SERVER_ADDR=127.0.0.1
: PWD=/www
: SERVER_PORT=80
: SCRIPT_NAME=/start.htm
: TZ=
: SERVER_NAME=127.0.0.1
: 
: stdin:
: 
: Bye.
*** call net-cgi from the command line
The following script may be copied into the firmware and used to call
net-cgi from the command line file:bin/call-cgi

Had to run =mkdir /proc/mounts= to appease =df= called by =net-cgi=.

** cross compiling =nvram-faker=
https://github.com/zcutlip/nvram-faker

Need to use the openwrt cross-compilation tool chain so that =uclibc=
will be used. see http://wiki.openwrt.org/doc/howto/buildroot.exigence

*** openwrt cross-compilation
- http://downloads.openwrt.org/docs/buildroot-documentation.html
- http://www.frontiernet.net/~beakmyn/CrossCompile.htm

** Original Article
http://shadow-file.blogspot.com/2013/10/complete-persistent-compromise-of.html

** Links for NETGEAR firmware
- http://www.userdrivers.com/LAN-Network-Adapter/Netgear-WNDR3700v4-Router-Firmware-Upgrade-1-0-1-42-All-Regions-Except-China-Russia/download/
- http://www.userdrivers.com/go.php?link=aHR0cDovL3d3dy5kb3dubG9hZHMubmV0Z2Vhci5jb20vZmlsZXMvR0RDL1dORFIzNzAwVjQvV05EUjM3MDBWNF9WMS4wLjEuNDIuemlw

** Notes from Zach Cutlip
Hi Eric,

I think the best approach is to describe how I set up my tool chain
and environment.  Hopefully that will be helpful for you.

To start with, I do my work in an Ubuntu VM.  Specifically 12.04.  I
don't think the exact release matters, but I know 12.04 works with my
tools.

I keep a set of cross compilers in my path for various
architectures. In my opinion, building with a cross compiler is faster
and easier than building with gcc inside QEMU.  I recommend building a
set of cross-compiling toolchains using Buildroot.  Buildroot uses a
Linux Kernel-style menuconfig build system.  I don't have anything
written up on building cross compilers, but I could probably send you
my buildroot configuration if you need it, and if I can find it.

You can download the firmware for the router from NETGEAR's support website.
Here's a link to the firmware:
http://support.netgear.com/product/wndr3700v4

In order to unpack the firmware, I recommend my colleague, Craig
Heffner's tool, Binwalk:
https://code.google.com/p/binwalk/

Binwalk will analyze a binary file and describe the subcomponents it
finds within, such as filesystems, compressed kernel,
etc. Additionally, it can unpack the subcomponents it finds, assuming
it knows how.
Install binwalk in your Ubuntu environment using the
"debian_quick_install.sh" installation script, which will apt-get
install a number of dependencies.
Rather than describe binwalk's usage, I'll refer you to the wiki:
https://code.google.com/p/binwalk/wiki/Usage?tm=6

Also, in your Ubuntu environment you'll need a Debian MIPS QEMU system
that you can use to emulate the firmware's binaries.

I found lots of information about running Debian in QEMU, but most of
it was incomplete, and a lot of it was inconsistent, so I've written a
blog post describing how I set up my QEMU systems:
http://shadow-file.blogspot.com/2013/05/running-debian-mips-linux-in-qemu.html

This is just personal, but I like to export my workspace to the QEMU
machines via NFS.  In fact, I export my workspace from my Mac via NFS,
and my Ubuntu VMs and Debian QEMU VMs all mount the same
directory. That way I'm not having to copy firmware, scripts and
debuggers around.

Once logged into your QEMU VM, you can chroot into the router's
firmware and run some of its binaries:

firmware_rootfs # chroot . /bin/sh
#

The simple ones, such as busybox, will run with no problem.  The web
server, upnp server, etc. are more complicated because they make a lot
of assumptions about the router's specific hardware being present.

One of the problems you run into has to do with queries to NVRAM for
runtime configuration.  Obviously, your Debian MIPS Linux has no
NVRAM, so these queries will fail.  For that, I have a project called
"nvram-faker":
https://github.com/zcutlip/nvram-faker

You build the library for your target and preload it using the
LD_PRELOAD environment variable.  It intercepts calls to nvram_get and
provides answers based on the contents an nvram.ini file that you
provide. It prints all the nvram queries to stdout, and colorizes the
ones that it couldn't find in the .ini file.  Obviously it takes some
guesswork to provide sane configuration parameters.

Sometimes you can skip running the web server and just run the cgi
binaries from a shell script.  Most cgi binaries take their input from
the web server as a combination of standard input and environment
variables.  They send their response to the web server over standard
output.

I hope this helps.  Let me know if I can help any other way.

Zach

